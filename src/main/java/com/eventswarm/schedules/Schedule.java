/**
 * Copyright 2007-2014 Ensift Pty Ltd as trustee for the Avaz Trust and other contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
*/
/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */

package com.eventswarm.schedules;

/**
 * Interface for classes defining schedules for use with ScheduleTrigger and
 * ScheduleAction.
 *
 * @author andyb
 */
import java.util.Date;

public abstract class Schedule implements Comparable<Schedule>, FirstTickAction {

    protected Date next;
    protected Clock clock;

    /**
     * Default constructor sets the next date to maximum possible value so that
     * it does not fire until the time is reset.
     */
    public Schedule() {
        this.next = new Date(Integer.MAX_VALUE);
    }

    /**
     * Constructor that sets the next date based on the specifed clock, if
     * initialised, or waits for the first clock tick if not intialised.
     *
     * Note that the clock is used only to intialise the schedule. All
     * subsequent times are set using the setTime method.
     */
    public Schedule(Clock clock) {
        this.setClock(clock);
    }
    
    /**
     * Return the time that the schedule should next fire as a java.util.Date
     */
    public Date next() {
        return this.next;
    }

    /**
     * Update the schedule to reflect the specified time, that is, next() returns
     * the next time the schedule should fire after the specified time.
     * 
     */
    public abstract void setTime(Date currentTime);

    /**
     * Use the specified clock to initialise the time associated with this
     * schedule (i.e. the time from which the schedule should first fire).
     *
     * If the clock is not yet initialised, the schedule will register an action
     * against the Clock's FirstTickTrigger if available so that it can be
     * intialised when the clock is inititalised.
     *
     * @param clock
     */
    public void setClock(Clock clock) {
        if (clock != null) {
            this.clock = clock;
            if (clock.isInitialised()) {
                this.setTime(clock.getTime());
            } else {
                // Not initalised.  If we can register for a FirstTickTrigger,
                // then do so
                if (FirstTickTrigger.class.isInstance(clock)) {
                    ((FirstTickTrigger) clock).registerAction(this);
                }
            }
        }
    }

    /**
     * Comparable method uses date of next firing to determine order when compared
     * to another Schedule
     */
    public int compareTo(Schedule sched) {
        return(this.next().compareTo(sched.next()));
    }

    /**
     * Comparable method compares date of next firing to the specified date when
     * compared to a Date object.
     * 
     * @param date
     * @return
     */
    public int compareTo(Date date) {
        return(this.next.compareTo(date));
    }

    /**
     * Set our current time to the time of the first tick generated by our
     * clock.
     * 
     * @param trigger
     * @param time
     */
    public void execute(FirstTickTrigger trigger, Date time) {
        this.setTime(time);
    }

}
